#한번 방문한 곳은 다시 방문하지 않는다. 

1) 시작점의 상태를 큐에 넣는다.

2) 큐에서 상태를 하나 꺼낸다. 이때, 아직 방문하지 않은 상태가 꺼내질 때까지 반복한다. 방문한 상태가 꺼내진다면 그 상태는 버린다. 이때 큐가 중간에 비면 6)으로 간다.

3) 이제 이 상태를 방문한 것이다. 이 상태가 도착점이면 6)으로 빠져나간다.

4) 이 상태의 인접해 있는 아직 방문하지 않은 상태들을 모두 큐에 넣는다.

5) 큐가 비어 있다면 6)으로, 아니라면 2)로 돌아간다.

6) 루프 끝. 도착점이 방문되지 않았다면, 도착점은 시작점으로부터 어떤 경로를 통해도 방문할 수 없다.

2) ~ 5)의 파란색 부분이 루프입니다.

이 코드는 도착점까지 절대 갈 수 없는지도 판별이 가능합니다.

큐가 비게 된다는 말은, 방문할 수 있는 건 다 했는데 더이상 방문할 상태도 남지 않았고, 도착점은 아직 방문되지 않았다는 말입니다. 따라서 도착점까지 갈 수 없다는 것이죠.


이때 방문한 상태임을 표시하는 것이 조금 신경쓰이는 부분입니다.

저는 대체로 이런 형태의 코드를 사용합니다.


0) visited 배열을 모두 false로 초기화한다. success = false로 초기화한다.

1) 시작점 상태를 S라 할 때, visited[S] = true로 하고 큐에 S를 넣는다.

2) 큐에서 맨 앞의 상태를 꺼내 C라고 한다.

3) C가 도착점 상태 E와 같다면 success = true로 하고 6)으로 빠져나간다.

4) C의 각 인접한 상태 N에 대해, visited[N] == false일 경우 visited[N] = true로 하고 큐에 N을 넣는다.

5) 큐가 비어 있다면 6)으로, 아니라면 2)로 돌아간다.

6) 루프 끝. success == false(혹은 visited[E] == false)라면, 도착점은 시작점으로부터 어떤 경로를 통해도 방문할 수 없다.

이렇게 하면 큐에는 한 상태는 반드시 한 번만 들어가게 됩니다.

따라서 각 상태는 많아봐야 한 번씩만 방문하게 됩니다.

도착점을 먼저 찾아버리면 방문하지 못하는 상태들도 존재할 수 있지만 이는 문제가 되지 않습니다.

그런데 아직 부족합니다. 우리는 도착점까지 몇 번만에 갈 수 있는지를 알아내야 하는데,

이를 구현하는 방법으로는

① 큐에 상태와 함께, 지금까지 이동한 거리도 넣는다.

② 바깥쪽 루프에서 미리 큐의 현재 사이즈를 잰 뒤, 안쪽 루프에서 측정된 현재 사이즈 번 만큼만 2) ~ 5)의 과정을 반복한다.


두 번째가 초심자들에게는 조금 더 쉽습니다. 저는 실제로 두 번째를 애용합니다.

이렇게 하면 바깥쪽 루프가 반복된 횟수를 가지고 거리를 바로 알 수 있기 때문입니다.

"큐의 현재 사이즈"는 이번 phase에서 방문하게 되는 상태의 개수를 의미하기도 합니다!!


https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=kks227&logNo=220574993422
