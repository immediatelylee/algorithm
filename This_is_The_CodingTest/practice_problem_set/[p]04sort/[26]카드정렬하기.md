https://www.acmicpc.net/problem/1715

문제
정렬된 두 묶음의 숫자 카드가 있다고 하자. 각 묶음의 카드의 수를 A, B라 하면 보통 두 묶음을 합쳐서 하나로 만드는 데에는 A+B 번의 비교를 해야 한다. 이를테면, 20장의 숫자 카드 묶음과 30장의 숫자 카드 묶음을 합치려면 50번의 비교가 필요하다.

매우 많은 숫자 카드 묶음이 책상 위에 놓여 있다. 이들을 두 묶음씩 골라 서로 합쳐나간다면, 고르는 순서에 따라서 비교 횟수가 매우 달라진다. 예를 들어 10장, 20장, 40장의 묶음이 있다면 10장과 20장을 합친 뒤, 합친 30장 묶음과 40장을 합친다면 (10 + 20) + (30 + 40) = 100번의 비교가 필요하다. 그러나 10장과 40장을 합친 뒤, 합친 50장 묶음과 20장을 합친다면 (10 + 40) + (50 + 20) = 120 번의 비교가 필요하므로 덜 효율적인 방법이다.

N개의 숫자 카드 묶음의 각각의 크기가 주어질 때, 최소한 몇 번의 비교가 필요한지를 구하는 프로그램을 작성하시오.

입력
첫째 줄에 N이 주어진다. (1 ≤ N ≤ 100,000) 이어서 N개의 줄에 걸쳐 숫자 카드 묶음의 각각의 크기가 주어진다. 숫자 카드 묶음의 크기는 1,000보다 작거나 같은 양의 정수이다.

출력
첫째 줄에 최소 비교 횟수를 출력한다.

예제 입력 1
3
10
20
40
예제 출력 1
100

.
.
.
.
.
.
.
.
.
.

1. 허프만 코딩알고리즘을 사용해서 풀수 있다.
   Huffman coding은 데이터 압축에 주로 사용되는 알고리즘으로, 각각의 데이터에 대해 가중치 또는 빈도를 기준으로 최적의 코드를 할당하는 방식

2. 일단 문제를 풀기 위해서는 허프만 코딩 알고리즘의 정의를 알 필요는 없다.

핵심은 가장작은 카드 묶음 두개를 더하는 과정이 있어야 한다는것이다.

- 총비교한 횟수(answer)를 0으로 둔다.
- 현재의 카드 묶음 중 가장 작은 2개의 카드 묶음을 꺼낸다. (우선순위큐 최소힙)
- 두개 더한값 = 현재 단게에서 비교한 횟수
- 두개를 더한값을 총 비교한 횟수에 더해준다.
- 두개를 더한값을 다시 카드 더미 않에 넣는다.

위의 과정을 힙에 하나의 덱만 남을 때 까지 반복 한다.

3.  위의 과정들을 차례대로 해보자면
    result =0
    카드묶음을 heap의 자료구조에 넣으므로 써 가장 최소 값을 출력하게 하기 위해
    heapq.heapify(cards)를 해준다. - heap생성

        a = heapq.heappop(cards)
        b = heapq.heappop(cards) 최소 값 두개 출력

    sum_value = a + b 현재단계에서 비교한 횟수
    result += sum_value 비교한 횟수를 총 비교한 횟수에 더해주기
    heapq.heappush(cards, sum_value) 힙에 넣어주므로써 다시 카드 더미 안에 넣기

이를 while문을 통해서 게속 반복하면 되는 문제이다.

4. 위에서 허프만 코딩이 나왔는데 데이터 압축에서 사용되는 주요한 코드이다.

기존에는 고정길이 코드를 통해서 사용되었는데
예를 들면 4개의 데이터를 표현하기 위해서 2비트의 코드를 할당한다면 데이터는 00 01 10 11 과 같이 고정된 피트 패턴으로 표현된다. 모든 데이터가 동일한 길이의 코드를 사용하기 때문에 디코딩이 간단하고 데이터의 위치를 정확히 알수 있다.
다만 데이터의 빈도에 관계 없이 비트를 부여 하기 때문에 빈도가 낮은 데이터는 비효율 적일 수 있다.

이에 비해 접두어 코드는 각 데이터에 서로 다른 길이의 코드를 할당하는 방식 이다. a코드의 접두어가 0 이고 b코드의 접두어가 1 이라면 c코드에는 0이나 1을 사용할 수 없다. 이런 특성 때문에 디코딩 과정에서 각 데이터의 위치를 명확히 구분할 수 있다.
빈도가 높은 데이터에는 짧은 코드를 할당하고, 빈도가 낮은 데이터에는 긴코드를 할당하여 전체적인 압축효율을 높인다.

https://en.wikipedia.org/wiki/Huffman_coding#/media/File:HuffmanCodeAlg.png
위의 링크의 이미지를 살펴보면
빈도가 적은 노드들을 빈 노드를 생성하여 각 왼쪽과 오른쪽에 위치시킨다.
이런식으로 반복하면 빈도가 높은 노드가 상위에 있게 되고 나머지 노드는 하위에 높이게 된다.

이 문제를 해결하기 위해, 최소힙(min-heap) 자료구조를 이용하면 간단하게 해결할 수 있습니다. 최소힙은 가장 작은 값이 항상 맨 앞에 오도록 유지되는 특별한 형태의 힙입니다.

아래는 파이썬으로 최소힙을 구현한 코드입니다. heapq 모듈을 이용하여 최소힙을 구현하였습니다. 각각의 묶음을 최소힙에 넣은 뒤, 두 개의 묶음씩 최소값을 찾아 합치고, 그 결과를 다시 최소힙에 넣는 과정을 반복합니다. 최소힙에서 값을 꺼내 합치는 과정은 최소값을 찾는 과정과 같으므로, 전체적인 시간 복잡도는 O(NlogN)으로 빠르게 해결할 수 있습니다.
